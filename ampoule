#!/usr/bin/env ruby
# Updated: November 2, 2009 by Oleg Andreev
#
# ABOUT
# 
# Ampoule is a minimal bug tracker based on Git.
# 
# To start, run ampoule executable inside any git repository. 
# You will be asked for a repository URL if it could not be guessed from .git/config
# Tasks are stored in human-readable YAML format in a separate branch "ampoule-tasks". 
# Your development history is never polluted with ampoule commits.
#
# Source code: git://github.com/oleganza/ampoule.git
#
#
# MIT LICENSE
#
# Copyright (c) 2009 Oleg Andreev <oleganza@gmail.com>
# 
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following
# conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

# We use only stdlib here to avoid infinite gem requirements
$KCODE = 'UTF8'
require 'webrick'
require 'CGI'
require 'jcode'
require 'thread'
require 'yaml'
require 'strscan'

# bugfix
module WEBrick::HTTPUtils
  def parse_form_data(io, boundary)
    # BUG here: boundary may contain '+' and will break regexp:
    # boundary_regexp = /\A--#{boundary}(--)?#{CRLF}\z/
    boundary_regexp = /\A--#{Regexp.quote(boundary)}(--)?#{WEBrick::CRLF}\z/
    form_data = Hash.new
    return form_data unless io
    data = nil
    io.each{|line|
      if boundary_regexp =~ line
        if data
          data.chop!
          key = data.name
          if form_data.has_key?(key)
            form_data[key].append_data(data)
          else
            form_data[key] = data 
          end
        end
        data = FormData.new
        next
      else
        if data
          data << line
        end
      end
    }
    return form_data
  end
  module_function :parse_form_data
end

module Kernel
  def const(name, value = nil)
    if !const_defined?(name)
      const_set(name, value || name.to_s.downcase)
    end
  end
end

module Ampoule
  
  const(:VERSION, "0.2")
  
  module GitHelper
    def git_user_name
      @git_user_name ||= `cd .git/ampoule; git config user.name`.strip
    end
    
    def git_user_email
      @git_user_email ||= `cd .git/ampoule; git config user.email`.strip
    end
    
    def git_user_name=(n)
      n = n.gsub(/["`'\\\n\r\t\v]+/, '')
      `cd .git/ampoule; git config user.name "#{n}"`
    end
  end
  
  module FileHelper
    include GitHelper
    
    def file_contents_for_path(path)
      $file_buffer.read(path).to_s.or { nil }
    end
    
    def file_contents_for_name(name)
      file_contents_for_path(".git/ampoule/#{name}")
    end
    
    def set_file_contents_for_name(content, name)
      path = ".git/ampoule/#{name}"
      $file_buffer.write(path, content)
    end
    
    def project_title
      (file_contents_for_name("title.txt") || "Click here to change project name").strip
    end

    def set_project_title(new_title)
      set_file_contents_for_name(new_title, "title.txt")
    end

    def tasks
      $file_buffer.glob(".git/ampoule/*.yaml").map do |path|
        if path =~ %r{/([\d\-]+)\.yaml$}
          Task.task_with_id_and_yaml($1, file_contents_for_path(path))
        else
          nil
          #raise "Task id is corrupted? Path: #{path}"
        end
      end.compact
    end

    def task_by_id(id)
      file_contents_for_name(%{#{id}.yaml}).and do |data|
        Task.task_with_id_and_yaml(id, data)
      end
    end
        
    def save_task(task)
      task.mark_as_modified
      update_user_names_with_name(task.assigned_to)
      set_file_contents_for_name(task.to_yaml, %{#{task.id}.yaml})
    end
    
    def current_user_name=(name)
      name = name.strip
      names = user_names
      names.delete(current_user_name)
      names << name
      self.user_names = names
      self.git_user_name = name
    end
    
    def current_user_name
      update_user_names_with_name(git_user_name)
      git_user_name
    end
    
    def user_names
      @user_names ||= begin
        names = (file_contents_for_name(%{user_names.yaml}).and do |data|
          YAML.load(data)
        end.or [])
      end
    end

    def user_names=(names)
      @user_names = names.sort
      set_file_contents_for_name(@user_names.to_yaml, %{user_names.yaml})
    end
    
    def update_user_names_with_name(name)
      names = user_names
      if name.and {|n| !names.include?(n) }
        names << name
        self.user_names = names
      end
    end
    
  end
  
  module PresentationBuilders
    if !defined? BlankSlate
      class BlankSlate
        class <<self; alias __undef_method undef_method; end
        alias __instance_eval instance_eval
        ancestors.inject([]){|m,a| m + a.methods }.uniq.
          each { |m| (__undef_method(m) rescue nil) unless m =~ /^__/ }
      end
    end
    
    class XMLBuilder < BlankSlate
      def initialize(delegate = nil, &blk)
        @delegate = delegate
        @buffer = ""
        run!(&blk) if blk
      end
      
      def with_modules(*modules)
        modules.each do |m|
          class <<self; self; end.send(:include, m)
        end
        self
      end
      
      def run!(&blk)
        __instance_eval(&blk)
        self
      end
      
      def puts(s)
        print("#{s}\n")
      end

      def print(text)
        @buffer << text
        ""
      end

      def tag(name, attrs = {}, &blk)
        @buffer << %{<#{name}} << (attrs || {}).inject('') do |ra, (k,v)|
          v = k if v == true
          v ? (ra << " " << k.to_s << "=" << '"' << CGI::escapeHTML(v.to_s) << '"') : ra
        end
        if blk
          @buffer << ">" << yield.to_s << "</#{name}>"
        else
          @buffer << " />"
        end
        ""
      end

      def method_missing(name, *args, &blk)
        tag(name, *args, &blk)
      end
      
      def delegate(*methods)
        if methods.empty?
          @delegate
        else
          methods.each do |m|
            class <<self; self; end.send(:define_method, m) do |*args| 
              @delegate.send(m, *args)
            end
          end
        end
      end
      
      def h(text)
        CGI::escapeHTML(text)
      end
      
      def hlink(text, &blk)
        scanner = StringScanner.new(text)
        buffer = ""
        entities = {
          "<" => "&lt;",
          ">" => "&gt;",
          '"' => "&quot;",
          '&' => "&amp;"
        }
        atmark = "@"
        proto = "://"
        mailto = "mailto:"    
        while 1
          return buffer if scanner.eos?
          if s = scanner.scan_until(%r{[<>"&]|[\w\+\-_]+://|\w[\.\w]*@}um)
            m = scanner.matched
            l = m.size
            r = 0..(-1 - l)
            buffer << s[r]
            if l == 1 # entity
              buffer << entities[m]
            else # url
              url = m.dup
              if s = scanner.scan(%r{[\w&\.,%;:_/\-\?\[\]=@]+[\w/]}um)
                url << s
              end
              buffer << ((blk && yield(url)) || begin
                url = CGI::escapeHTML(url)
                pfx = nil
                if url[atmark] && !url[proto]
                  pfx = mailto
                end
                %{<a href="#{pfx}#{url}">#{url}</a>}
              end)
            end
          else
            buffer << scanner.rest
            return buffer
          end
        end
      end # hlink
      
      def to_s
        @buffer
      end
    end
      
    class CSSBuilder < BlankSlate

      class ::Numeric
        def em; "#{self}em"; end
        def px; "#{self}px"; end
      end

      def initialize(&blk)
        @css = {}
        @current_selector = ""
        @current_rules = {}
        __instance_eval(&blk)
      end

      def _selector(name, suffix = "", &blk)
        # 0. prepare
        suffix = ":#{suffix}" if suffix.is_a?(Symbol)
        selector = "#{name}#{suffix}"

        # 1. push
        current_selector = @current_selector
        @current_selector = "#{current_selector} #{selector}".strip
        rules = @current_rules
        @current_rules = {}

        yield

        # 2. remember collected stuff
        @css[@current_selector] ||= {}
        @css[@current_selector].merge! @current_rules

        # 3. pop
        @current_rules = rules
        @current_selector = current_selector
      end

      # define an element
      def _(suffix = "", &blk)
        _selector("", suffix, &blk)
      end

      # set any property as-is
      def _set(name, value)
        @current_rules[name.to_s] = value
        nil
      end

      def _property(name, value_or_hash)
        if value_or_hash.is_a?(Hash)
          value_or_hash.inject(nil) do |r, (k, v)|
            _property("#{name}-#{k}", v)
          end
        else
          _set(name.to_s.gsub("_","-"), value_or_hash)
        end
      end

      def method_missing(name, *args, &blk)
        blk ? _selector(name, *args, &blk) : _property(name, *args)
      end

      def to_s
        @css.inject("") do |css, (selector, props)|
          css << "#{selector} {\n" << (props.inject("") { |_, (k,v)|
            _ << "  #{k}: #{v};\n"
          }) << "}\n"
        end
      end
    end # CSSBuilder
    
  end # PresentationBuilders

  #
  # Model
  #
  
  NonreloadableStructs = {} if !defined?(NonreloadableStructs)
  class <<self
    def Model(*attrs)
      key = attrs.map{|a|a.to_s}.join(",")
      model = (NonreloadableStructs[key] ||= Struct.new(*attrs))
      model.send(:include, ModelInstanceMethods)
      model.send(:extend, ModelClassMethods)
      model
    end
  end
  
  module ModelClassMethods
    def default(name, &blk)
      send(:define_method, name) do
        super.or { instance_eval(&blk) }
      end
    end
  end
  
  module ModelInstanceMethods
    def initialize(attrs)
      attrs.each do |key, value|
        send("#{key}=", value)
      end
    end
    
    # do not export @ivars
    def to_yaml_properties; []; end
    
    # for to_yaml: access data directly through method sends so that all defaults are used
    def [](key); send(key); end
  end
      
  class Task < Model(:title, :priority, :assigned_to, :status, :created_at, :modified_at, :comments)
    attr_accessor :id
    
    const :OPENED
    const :CLOSED
    
    def self.task_with_id_and_yaml(id, data)
      t = YAML.load(data)
      t.id = id
      t
    end
    
    const :PRIORITIES, %w[today this\ week later never]
    
    def priorities; PRIORITIES; end
    
    def id
      @id ||= Time.now.strftime("%Y%m%d-%H%M%S-#{rand(2**16).to_s.rjust(5,'0')}")
    end
    
    default(:title)       { "Untitled" }
    default(:priority)    { priorities.first }
    default(:assigned_to) { "nobody" }
    default(:created_at)  { Time.now }
    default(:modified_at) { Time.now }
    default(:comments)    { self.comments = [] }
    
    def status
      super == CLOSED ? CLOSED : OPENED
    end
    
    def closed?
      status == CLOSED
    end
    
    def opened?
      !closed?
    end
    
    def last_status_line
      last_comment = comments.last
      return "" if !last_comment
      if !last_comment.body.blank?
        %{#{last_comment.author}: #{last_comment.body.to_short_line}}
      elsif !last_comment.status.blank?
        %{#{last_comment.status} by #{last_comment.author}}
      else
        ""
      end
    end
    
    # mutation methods
        
    def close; self.status = CLOSED; end
    def open;  self.status = OPENED; end
    
    def add_comment(comment)
      comments << comment
    end
    
    def mark_as_modified
      self.modified_at = Time.now
    end
  end
  
  class Comment < Model(:author, :date, :status, :body, :attachments)
    default(:date) { Time.now }
    default(:attachments) { self.attachments = [] }
    
    def body
      super.to_s
    end
  end
  
  class Attachment < Model(:name, :local_filename, :size)
    default(:name) { "Untitled" }
    default(:local_filename) { self.local_filename = rand(2**128).to_s }
    default(:size) { 0 }
    
    def store_file(data)
      folder = ".git/ampoule/attachments"
      if !File.readable?(folder)
        Dir.mkdir(folder)
      end
      $file_buffer.write("#{folder}/" + local_filename, data)
      self
    end
  end
  
  #
  # Controllers
  #

  class Controller
    attr_accessor :request, :response
    def initialize(request, response)
      self.request = request
      self.response = response
      response.status = 200
      response['Content-Type'] = "text/html"
    end
    
    def param(param, default = nil)
      r = request.query[param.to_s] || default
      return r.to_s if r.is_a?(String) # fight WEBrick::HTTPUtils::FormData 
      r
    end
    
    class Upload < Ampoule::Model(:name, :filename, :data)
      default(:filename) { rand(2**128).to_s }
      def size
        data ? data.size : 0
      end
    end
    
    def uploaded_files(param = "file[]")
      r = request.query[param.to_s] || nil
      if r
        a = []
        r.each_data do |d|
          if d && d.size > 0
            a << Upload.new(:name => d.name, :filename => d.filename, :data => d)
          end
        end
        a
      else
        []
      end
    end
    
    def get!
      response.body = get.to_s
    end
    
    def get
      ""
    end
    
    def post!
      post
      if @redirect_to
        response.status = 301
        response['Location'] = @redirect_to
      end
    end
    
    def post
      redirect_to "/"
    end
    
    def redirect_to(uri)
      @redirect_to = uri
    end
  end
  
  module LayoutHelpers

    def tasks_table(tasks, opts, &blk)
      opts = opts.dup
      tasks ||= []
      cls = ["tasks", opts.delete(:class), opts.delete("class")].compact.join(" ")
      table({:border => 0, :class => cls}.merge(opts)) do
        blk.call if blk
        tasks.each do |task|
          tr do
            td(:class => "task-title textual") do
              a(:href => "/#{task.id}"){ h(task.title) }
              small do
                status = task.last_status_line.
                            gsub(/assigned to .*? (by .*)/i, "reassigned \\1").
                            gsub(/([^\.])\.\Z/,"\\1")
                puts(h(status) + " ")
                nobr { task.modified_at.to_relative_string_if_recent.and{|s| "(#{s})" }.to_s} 
              end
            end
            td(:class => "task-person textual") do
              div :class => "assigned-to" do
                puts h(task.assigned_to)
                reassign_tag(:value => task.assigned_to, :task_id => task.id)
              end
            end
          end
        end # tasks.each
        ""
      end # table
    end # tasks_table
    
    def formatted_text(text)
      return "" if text.blank?
      text = text.gsub(/\r\n/, "\n").gsub(/\r/, "\n")
      
      # 1. Unwrap link to task 
      text.gsub!(%r{http://localhost:\d+/(\d{8}-\d{6}-\d+)/?}, "task \\1")
      
      text = text.split(/\n\n+/).map do |paragraph|
        if paragraph[/^[ \t]+/]
          %{<code><pre>#{hlink(paragraph)}</pre></code>}
        else
          %{<p>#{hbr(paragraph)}</p>}
        end
      end.join
      
      # 2. Wrap task id into link
      text.gsub!(%r{((task|case|bug) (\d{8}-\d{6}-\d+))}, %{<a href="/\\3">\\1</a>})
      
      text
    end # formatted_text

    def hbr(text)
      hlink(text.strip).gsub(/\n/, "<br/>")
    end
    
    def submit_button(attrs, &blk)
      input({:type => :submit,
             :name => :submit,
             :value => :Ok,
             :disabled => !!attrs.delete(:disabled)}.merge(attrs), &blk)
    end
    
    def select_tag(attrs, &blk)
      value = attrs.delete(:value)
      options = (attrs.delete(:options)||[]) | [value].or([])
      select(attrs) do
        options.each do |opt|
          option(:selected => (opt == value)) { opt }
        end
        yield if blk
        nil
      end
    end # select_tag

    def assign_tag(attrs)
      select_tag({:name => :assigned_to, :options => user_names, :onchange => "return onAssign(this);"}.merge(attrs)) do
        hr
        option { "New person..." }
      end
    end
    
    def reassign_tag(attrs)
      task_id = attrs[:task_id] or raise(ArgumentError, ":task_id is not specified!")
      assign_tag({:onchange => "return onReassign(this, #{task_id.inspect});"}.merge(attrs))
    end
    
    def pretty_file_size(bytes)
      kbs = bytes / 1024.0
      mbs = kbs / 1024.0
      return ("%.1f Mb" % mbs) if mbs > 0.9
      return ("%.1f Kb" % kbs) if kbs > 0.9
      "#{bytes.to_i} bytes"
    end
    
    def attachments(comment)
      div :class => "attachments" do
        pictures, files = comment.attachments.partition{|a| a.name =~ /\.(png|jpeg|jpg|gif|tiff|bmp|svg)$/ }
        pwd = Dir.pwd
        url_prefix = %{/attachments/}
        files.each do |f|
          div :class => "file attachment" do
            a(:href => "#{url_prefix}#{f.local_filename}") { h(f.name) }
            puts " "
            span { pretty_file_size(f.size) }
          end
        end
        div :class => "pictures" do
          pictures.each do |f|
            div :class => "picture attachment" do
              a(:href => "#{url_prefix}#{f.local_filename}") { 
                img(:src => "#{url_prefix}#{f.local_filename}", :border => "0")
              }
            end
          end
          ""
        end
      end
    end
    
  end # LayoutHelpers
  
  class AppController < Controller
    include FileHelper
    attr_accessor :page_title
    
    def page_title
      @page_title || project_title
    end
    
    def default_assigned_to
      $last_assigned_person.or { current_user_name }
    end
    
    def layout(attrs_for_body = {}, &page_content_block)
      PresentationBuilders::XMLBuilder.new(self).with_modules(LayoutHelpers).run! do
        
        delegate :project_title, :page_title, 
                 :current_user_name, :default_assigned_to, :user_names
        
        html do
          head do
            meta "http-equiv" => "Content-Type", :content => "text/html; charset=UTF-8"
            link :rel => "stylesheet", :href=>"/style.css", :type => "text/css"
            title { page_title }
          end
          if domid = attrs_for_body.delete(:focus)
            attrs_for_body[:onload] = %{document.getElementById('#{domid}').focus()} 
          end
          body(attrs_for_body) do
            
            script do
              %{
                var initialPersonSelectTagValue = #{default_assigned_to.inspect}
                function onAssign(selectTag) {
                  if (selectTag.value != "New person...") {
                    initialPersonSelectTagValue = selectTag.value
                    return
                  }
                  var newName = prompt('New person name')
                  if (!newName) {
                    selectTag.value = initialPersonSelectTagValue
                    return
                  }
                  var opt = document.createElement('option')
                  opt.setAttribute('value', newName)
                  opt.appendChild(document.createTextNode(newName))
                  selectTag.insertBefore(opt, selectTag.getElementsByTagName("hr").item(0))
                  selectTag.value = newName
                }
                function onReassign(selectTag, taskId) {
                  onAssign(selectTag);
                  var form = document.createElement("form")
                  form.setAttribute("method", "POST")
                  form.setAttribute("action", "/reassign")
                  var taskIdTag = document.createElement("input")
                  taskIdTag.setAttribute("name", "task_id")
                  taskIdTag.setAttribute("value", taskId)
                  var assignedTo = document.createElement("input")
                  assignedTo.setAttribute("name", "assigned_to")
                  assignedTo.setAttribute("value", selectTag.value)
                  form.appendChild(assignedTo)
                  form.appendChild(taskIdTag)
                  form.submit()
                }
                function addAnotherFileField(field)
                {
                  var parent = field.parentNode
                  var newField = document.createElement("input")
                  newField.setAttribute("type", "file")
                  newField.setAttribute("name", field.getAttribute("name"))
                  newField.setAttribute("onchange", field.getAttribute("onchange"))
                  field.setAttribute("onchange", "")
                  var br = document.createElement("br")
                  parent.insertBefore(br, field.nextSibling)
                  parent.insertBefore(newField, br)
                }
              }
            end
            
            __instance_eval(&page_content_block) if page_content_block
            br
            br
          end
        end # html
      end # XMLBuilder
    end # layout
  end # Layout
  
  class TasksController < AppController
    
    def get
      if current_user_name.blank?
        user_name_prompt
      else
        index
      end
    end
    
    def user_name_prompt
      layout :focus => :username do
        form :action => "/username", :method => "POST" do
          p { "Hello, what is your name?" }
          p { small { "Your name will be stored in .git/config" } }
          p do 
            input(:value => "", :name => :name, :id => :username) 
            submit_button(:value => "save")
          end
        end
      end
    end
    
    def index
      
      opened_tasks = []
      closed_tasks = []
      tasks.each do |t|
        (t.closed? ? closed_tasks : opened_tasks) << t
      end
      opened_tasks = opened_tasks.sort_by {|t| -t.modified_at.to_i }
      closed_tasks = closed_tasks.sort_by {|t| -t.modified_at.to_i }
      
      opened_tasks_by_priority = opened_tasks.inject({}) do |hash, task|
        (hash[task.priority] ||= []) << task
        hash
      end
      
      priorities = Task::PRIORITIES
      
      layout :focus => :newitemtitle do
        
        form :action => "/title", :method => "POST" do
          h1(:class => 'index-title') { input(:value => page_title, :name => :title) }
        end
                
        form(:action => "/", :method => :POST, :class => 'new-task') do
          tasks_table(opened_tasks_by_priority[priorities.first], :class => "opened-tasks") do
            tr :class => "new-task-row" do
              td :class => "task-title" do
                input(:name => "title", :value => "", :id => :newitemtitle)
              end
              td :class => "task-person" do
                nobr do
                  assign_tag(:value => default_assigned_to)
                  submit_button(:value => :Assign)
                end
              end # td
            end # tr
          end # tasks_table
        end # new task form
        
        priorities[1..-1].each do |priority|
          tasks = opened_tasks_by_priority[priority]
          if !tasks.blank?
            h3 { priority }
            tasks_table(tasks, :class => "opened-tasks")
          end
        end
        
        h2 { "Closed tasks" } if !closed_tasks.empty?
        
        tasks_table(closed_tasks, :class => "closed-tasks")
        
      end # layout
    end # index
    
    def post
      title = param(:title)
      assigned_to = param(:assigned_to)
      task = Task.new(:title => title, :assigned_to => assigned_to)
      task.add_comment(Comment.new(:author => current_user_name, :status => "opened"))
      save_task(task)
      $last_assigned_person = assigned_to
      redirect_to "/"
    end
    
  end # TasksController
  
  class TaskController < AppController
    
    def task
      @task ||= task_by_id(request.path[1..-1])
    end
    
    def get
      self.page_title = task.title + " (#{project_title})"
      
      layout :focus => :comment do
        
        delegate :task
              
        small(:style => %{position:absolute; top:1em;}) { a(:href => "/") { project_title + " index" } }
        
        form(:action => "/#{task.id}", :method => :POST, :class => 'edit-task', :enctype => "multipart/form-data") do
          h1 { input(:name => :title, :value => task.title, :class => "task-title") }
          
          div :class => "comments" do
            task.comments.each do |comment|
              label :class => "comment-label" do
                puts(h(comment.author))

                small { comment.status.to_s + " " + comment.date.to_relative_string }
              end
              puts(formatted_text(comment.body))
              attachments(comment)
            end
            ""
          end
          br
          input :class => "current-person", 
                :name => 
                :current_person, 
                :value => current_user_name, 
                :tabindex => -1
          br
          textarea(:name => :comment, :id => :comment, :rows => 10, :cols => 80) { }
          
          div :class => "buttons panel" do
            div :class => "save-buttons" do
              label { "assigned to " }
              assign_tag(:value => task.assigned_to)
              label { "priority " }
              select_tag(:name => :priority, :value => task.priority, :options => task.priorities)
              submit_button(:name => :save, :value => :Save)
            end
            div :class => "status-buttons" do
              submit_button(:name => :close, :value => :Close, :disabled => task.closed?)
              submit_button(:name => :reopen, :value => :Reopen, :disabled => task.opened?)
            end
          end
          
          div :class => "upload panel" do
            input :type => "file", :name => "file[]", :onchange => "addAnotherFileField(this); return true"
          end
        end # form
        
      end # super do
    end # read
    
    def safe_filename(n)
      ext = $1 if n =~ /(\.\w+)$/
      "#{rand(2**128).to_s(16)}#{ext}"
    end
    
    def post      
      
      current_person = param(:current_person)
      if current_person != current_user_name && !current_person.blank?
        self.current_user_name = current_person # remember new value
      end
      
      attachments = []
      uploaded_files.each do |f|
        attachment = Attachment.new(:name => f.filename,
                                    :local_filename => safe_filename(f.filename),
                                    :size => f.size)
        attachment.store_file(f.data)
        attachments << attachment
      end
      
      task.title = param(:title)
      task.priority = param(:priority)
      assigned_to = param(:assigned_to)
      
      status = nil
      if task.assigned_to != assigned_to
        status = %{assigned to #{assigned_to}}
      end
      
      task.assigned_to = assigned_to
      
      status_changed = !param(:close).blank? || !param(:reopen).blank?
      
      if status_changed
        if param(:close).blank?
          status ||= "reopened"
          task.open
        else
          status ||= "closed"
          task.close
        end
      end
      
      comment_body = param(:comment)
      if !status.blank? || !comment_body.blank? || !attachments.blank?
        comment = Comment.new(:author => current_user_name,
                              :status => status,
                              :body   => comment_body,
                              :attachments => attachments)
        task.add_comment(comment)
      end
      
      save_task(task)
      
      if status_changed
        redirect_to "/"
      else
        redirect_to request.path
      end
    end
    
  end # TaskController
  
  
  #
  # CSS
  #
  
  class CSSController < AppController
    def get
      PresentationBuilders::CSSBuilder.new do
        app_font_family = "Helvetica, sans-serif"

        body {
          font   "100% #{app_font_family}"
          color  "#333"
          margin "3em 1em 1em 7em"    
        }

        h1 {
          font_size 1.3.em

          input {
            font  "100% #{app_font_family}"
            width "70%"
          }
        }

        h1 ".index-title" do
          input {
            border        "1px solid #fff"
            width         "70%"
            margin_left   -1.px # compensation for the 1px border
            outline_style :none
          }
          input(:focus) {
            border_color "#ddd"
          }
        end

        h2 { 
          font :size => 1.1.em, :weight => :normal
          margin "1.8em 0 0.5em 0"
          color "#666"
        }
        
        h3 {
          font :size => "0.9em", :weight => :normal
          margin "1em 0 -1.39em -7em"
          width 6.em
          color "#999"
          text_align :right
        }
        
        a { color "#333" }
        a(:hover) { color "#000" }
        
        monospace = (Proc.new { font :family => "Consolas, Monaco, monospace" })
        code(&monospace)
        pre(&monospace)
        
        form ".new-task" do
          margin 0;
          
          input do
            font :family => app_font_family, :size => 1.0.em
          end
          
          select do
            margin_left -3.px
          end
        end
        
        _ ".tasks" do
          width       "100%"
          margin_left "-1px"
          
          td do 
            font     :family => app_font_family, :size => 0.9.em
            line_height "120%"
            padding  "2px 0 2px 0"
          end
          td(".textual") { vertical_align :top }
          td(".task-person") do 
            font_size 0.83.em
            
            div ".assigned-to" do
              position :relative
              overflow :hidden
              select do
                position :absolute
                top 0
                left 0
                opacity 0
                height "100%"
                outline_style :none
              end
            end
            
            div ".assigned-to:hover" do
            end
          end
                    
          _ ".new-task-row td" do
            padding_top "0.5em"
          end
          
          a         { color "#333"; text_decoration :none }
          a(:hover) { color "#000"; text_decoration :underline }

          _ ".task-title" do
            width "70%"
            padding_right "7px"

            input { width "100%" }
          end

          small {
            color "#999"
            font_size 0.75.em
            padding_left 0.4.em
          }

        end

        _ ".tasks.closed-tasks" do
          td { color "#666" }
          a  { color "#666" }
          a(:hover) { color "#333" }
        end

        _ ".edit-task" do
          textarea do
            font :size => 0.9.em, :family => app_font_family
            padding 0.4.em
            margin "0.4em 0 0.6em 0"
            word_spacing :normal
            width "70%"
          end

          input ".current-person" do
            padding 0
            margin 0
            border :none
            outline_style :none
            font :size => 0.8.em, :family => app_font_family, :weight => :bold
          end

          div ".panel" do 
            position :relative
            width "70%"
            padding 1.px # so we do not cut aqua button half-pixel edge
            overflow :hidden
            margin_bottom 0.5.em
            input ", select" do 
              font :size => "100%", :family => app_font_family
            end
          end
          
          div ".panel.upload" do
            padding_top  1.em
            margin_left  -1.px
            overflow :visible
            font :size => 0.9.em
            input do
              display :block
              margin_bottom 10.px
            end
          end

          div ".status-buttons" do
            float :left
            font_size 0.9.em
            input  { margin_right 0.6.em; width 4.5.em }
            select { margin_right 0.6.em }
          end
          
          div ".save-buttons" do
            float :right
            font_size 0.9.em
            input  { margin_left 0.6.em }
            input '[type="submit"]' do width 5.em; end
            select { margin_left 0.6.em }
            
            label do
              font_size 0.9.em
              margin_left 1.em
              margin_right -0.5.em
            end
            
          end
          
          input '[type="submit"]' do
            font :family => app_font_family, :size => 1.em
          end
          
          select '[name="priority"]' do
            width 7.em
          end
        end

        _ ".comments" do
          label {
            font :size => 0.8.em, :weight => :bold
            display :block
            margin "2em 0 0.6em 0"
            small {
              font :size => 1.em, :weight => :normal
              color "#999"
              padding_left 0.3.em
            }
          }

          p {
            font_size 0.9.em
            margin "0.3em 0 0.6em 0"
            width "70%"
            line_height "130%"
          }
          
          div ".attachments" do
            position :relative
            xoverflow :hidden
            margin "5px 0"
            font :size => 0.9.em 
            
            div ".file.attachment" do
              margin "0px 0 5px 0"
              span do
                font :size => 0.85.em
                color "#666"
              end
            end
            
            div ".pictures" do
              position :relative
              # overflow :hidden
              # padding "20px"
              # margin "-20px"
            end
            
            img do
              #float :left
              margin "10px 15px 10px 0"
              _webkit_box_shadow "#666 0px 5px 15px"
              max_width "70%"
            end
          end
          
        end
        
      end # builder
    end # get
  end # CSSController
  
  class TitleController < AppController
    def post
      set_project_title(param(:title))
      redirect_to "/"
    end
  end
  
  class UsernameController < AppController
    def post
      self.current_user_name = param(:name)
      redirect_to "/"
    end
  end
  
  class ReassignController < AppController
    def post
      task = task_by_id(param(:task_id))
      assigned_to = param(:assigned_to)
      if task && assigned_to
        task.assigned_to = assigned_to
        save_task(task)
      end
      redirect_to "/"
    end
  end
  
  #
  # Other
  #  
  
  class Actor
    attr_accessor :queue

    def self.new_instance(*args)
      actor = self.allocate
      actor.send(:initialize, *args)
      actor
    end

    def self.new(*args)
      Receiver.new(new_instance(*args))
    end

    def initialize
      @queue = Queue.new
      @thread = Thread.new do
        loop do
          msg, args, blk = @queue.pop
          send(msg, *(args||[]), &blk)
        end
      end
      @thread.abort_on_exception = true
    end
    
    def stop; @thread.join; end
    def kill; @thread.kill; end
    
    class Receiver
      def initialize(actor)
        @actor = actor
      end
      def send(name, *args, &blk)
        @actor.queue.push([name, args, blk])
        self
      end
      def method_missing(name, *args, &blk)
        send(name, *args, &blk)
      end
      def stop
        @actor.queue.clear
        send(:kill)
        @actor.stop
      end
    end

  end
  
  class FileSyncBuffer
    
    class Pusher < Actor
      def push
        # do not push if head did not change
        new_head = (File.read(".git/ampoule/.git/refs/heads/ampoule-tasks") rescue nil)
        if @head != new_head
          @head = new_head
          system %{cd .git/ampoule; git pull; git push} if !ENV["AMPOULE_NOPUSH"]
        end
      end
    end
    
    class Commiter < Actor
      def initialize(pusher, buffer, mutex)
        super()
        @pusher = pusher
        @buffer = buffer
        @mutex  = mutex
      end
      def commit
        system "cd .git/ampoule; git pull"
        paths = []
        @mutex.synchronize do
          @buffer.each do |path, data|
            paths << path
            File.open(path, 'w'){|f|f.write(data)}
          end
          @buffer.update({})
        end
        system %{cd .git/ampoule; git add .; git commit -m "synced #{paths.join(', ')}";}
        @pusher.push
      end
    end
    
    class Puller < Actor
      def initialize(interval = 1)
        super()
        @interval = interval
        self.queue.push([:pull])
      end
      def pull
        r = `cd .git/ampoule; git pull` if !ENV["AMPOULE_NOPULL"]
        if r.strip !~ /^Already up-to-date\.?/
          puts r
        end
        sleep(rand(@interval*2))
        self.queue.push([:pull])
      end
    end
    
    def initialize
      @buffer = {} # path => content
      @mutex = Mutex.new
      @pusher = Pusher.new
      @commiter = Commiter.new(@pusher, @buffer, @mutex)
      @puller = Puller.new
      @puller.pull
    end
    
    def stop
      puts "Ampoule::FileSyncBuffer: stopping..."
      @puller.stop
      @commiter.stop
      @pusher.stop
      puts "Ampoule::FileSyncBuffer: stopped."
    end
    
    def read(path)
      @mutex.synchronize do
        @buffer[path] || (File.readable?(path) ? File.open(path){|f|f.read} : nil)
      end
    end
    
    def write(path, data)
      @mutex.synchronize do
        puts "Buffered #{data.size} bytes to #{path}" if ENV["DEBUG"]
        @buffer[path] = data
      end
      @commiter.commit
    end
    
    def glob(wildcard)
      @mutex.synchronize do
        (Dir.glob(wildcard) || []) | @buffer.keys.grep(Regexp.new(wildcard.gsub(".","\\.").gsub("*",".*")))
      end
    end
  end
  
  
  
  #
  # Server config
  #
  
  def self.setup
    return if File.readable?(".git/ampoule")
    
    `git clone -n -s . .git/ampoule`
    
    url_for_origin = Proc.new do |origin|
      if origin[%r{[@\./:]}]
        origin
      else
        `git config remote.#{origin}.url`.strip
      end
    end
    
    ensure_url = Proc.new do |url|
      url.or do
        print "URL for the repository to sync with: "
        while (s = gets).blank?; end
        s.strip
      end.strip
    end
    
    configure = Proc.new do |url|
      `cd .git/ampoule; git config remote.origin.url #{url}`
      `cd .git/ampoule; git config remote.origin.fetch +refs/heads/ampoule-tasks:refs/remotes/origin/ampoule-tasks`
      `cd .git/ampoule; git config remote.origin.push ampoule-tasks:refs/heads/ampoule-tasks`
      
      `cd .git/ampoule; git config branch.ampoule-tasks.remote origin`
      `cd .git/ampoule; git config branch.ampoule-tasks.merge refs/heads/ampoule-tasks`
    end
    
    `git fetch 2>&1` # ensure that we have all branches up to date
    
    if `git branch -r` =~ %r{(\w+)/ampoule-tasks}
      origin = $1
      puts "Checking out ampoule-tasks branch..."
      url = ensure_url[url_for_origin[origin]]
      configure[url]
      `cd .git/ampoule; git fetch 2>&1`
      `cd .git/ampoule; git checkout -b ampoule-tasks remotes/origin/ampoule-tasks 2>&1`
      
    else
      puts "Creating ampoule-tasks branch..."
      head = (File.read(".git/HEAD") rescue "")
      if head =~ %r{ref: refs/heads/(\w+)}
        origin = `git config branch.#{$1}.remote`.strip
        url = url_for_origin[origin]
      end
      url = ensure_url[url]
      configure[url]
      
      `cd .git/ampoule; git status 2>&1` # this triggers index update so all items are marked as removed
      `cd .git/ampoule; git checkout -b ampoule-tasks 2>&1`
      `cd .git/ampoule; git commit -a -m "clean-up working directory after clone" 2>&1`
      # creating dangling branch:
      tree = `cd .git/ampoule; git log -1 --pretty=format:%T`.strip
      commit = `cd .git/ampoule; echo "initial commit" | git commit-tree #{tree}`.strip
      `cd .git/ampoule; git reset --hard #{commit}`
      
      pull_result = `cd .git/ampoule; git pull 2>&1`
    end
    
    # TODO: ask for the user.name & store in .git/ampoule/.git/config
    
  end
  
  class Server
    def initialize(opts = {})
      @opts = opts
      @port = @opts[:port].to_i
      $file_buffer = FileSyncBuffer.new
      begin
        @server = WEBrick::HTTPServer.new(
          :BindAddress => "127.0.0.1", # so it is not accessible from outside
          :Port => @port,
          :Logger => WEBrick::Log.new(nil, ENV["DEBUG"] ? WEBrick::BasicLog::DEBUG : WEBrick::BasicLog::WARN),
          :AccessLog => (ENV["DEBUG"] ? nil : [])
        )
      rescue Errno::EADDRINUSE
        @port += 1
        $stderr.puts "Ampoule::Server: trying to bind to port #{@port}..."
        retry
      end
      @server.mount "/attachments", WEBrick::HTTPServlet::FileHandler, Dir.pwd+"/.git/ampoule/attachments"
      @server.mount "/", WebrickHandle, self
    end
    
    def controller_class_for_request(request)
      case request.path
      when "/":            TasksController
      when "/title":       TitleController
      when "/username":    UsernameController
      when "/reassign":    ReassignController
      when "/style.css":   CSSController
      when "/favicon.ico": Controller
      else                 TaskController
      end
    end
    
    def start
      Thread.new { sleep(1); system(%{open http://localhost:#{@port}/}) }
      trap("INT") { @server.shutdown; $file_buffer.stop }
      @server.start
    end
  end
  
  class WebrickHandle < WEBrick::HTTPServlet::AbstractServlet
    def initialize(_server, router)
      @router = router
      super(_server)
    end
        
    def controller_for_request_and_response(request, response)
      @router.controller_class_for_request(request).new(request, response)
    end
    
    def before
      load(__FILE__) if ENV['AMPOULE_AUTORELOAD']
    end
    
    def do_GET(request, response)
      before
      controller_for_request_and_response(request, response).get!
    end
    
    def do_POST(request, response)
      before
      controller_for_request_and_response(request, response).post!
    end
  end

  module CoreExtensions
    
    class ::Time
      def to_relative_string
        diff = (Time.now - self).to_i
        return "now" if diff < 2
        return "#{diff} seconds ago" if diff < 50
        return "one minute ago" if diff < 60*2
        return "#{diff/60} minutes ago" if diff < 60*60
        return "an hour ago" if diff/60/60 <= 1
        return "#{diff/60/60} hours ago" if diff < 60*60*18
        return "yesterday" if diff/60/60/24 <= 1
        return "#{diff/60/60/24} days ago" if diff < 60*60*24*7
        return strftime("%B %d") if diff < 60*60*24*30*3
        return strftime("%B %d, %Y")
      end
      def to_relative_string_if_recent
        if Time.now - self < 3600*20
          to_relative_string
        else
          ""
        end
      end
    end
    
    class ::NilClass
      def next_ampoule_id(offset = 3)
        ("0"*(offset + 1)).next_ampoule_id(offset)
      end
    end
    
    class ::String
      
      def next_ampoule_id(offset = 3)
        d = 10**offset
        c = to_i/d + 1
        "#{c}#{rand(d).to_s.rjust(offset,'0')}"
      end
      
      def to_short_line
        max_len = 40
        if gsub("\n"," ") =~ %r{\A(.{10,#{max_len}}\S[\.\?\!\(\[\{]\s)}u
          $1.gsub(/\s*[\(\[\{]\Z/,"")
        elsif self.size > max_len
          split(//u)[0,max_len].join.gsub(/\s*[\(\[\{]\Z/,"") + "..."
        else
          self.gsub(/\s*[\(\[\{]\Z/,"")
        end
      end
    end

    class ::Object
      def blank?; false end
      def or(default = nil)
        blank? ? (block_given? ? yield : default) : self 
      end
      def and
        blank? ? nil : yield(self)
      end
    end
    class ::FalseClass
      def blank?; true end
    end
    class ::NilClass
      def blank?; true end
    end
    class ::Array
      def blank?; compact.empty? end
    end
    class ::String
      def blank?; strip.empty? end
    end
    class ::Hash
      def blank?; values.empty? end
    end
  end # CoreExtensions
end

if $0 == __FILE__
  
  Ampoule::setup
  
  if ARGV.shift == "-i"
    require 'irb'
    include Ampoule
    $file_buffer = FileSyncBuffer.new
    include FileHelper
    IRB.start
  elsif !defined?(Ampoule::ServerInstance)
    Ampoule::ServerInstance = Ampoule::Server.new(:port => 8000)
    Ampoule::ServerInstance.start
  end
end

__END__





