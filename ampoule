#!/usr/bin/env ruby
# Updated: 28 October, 2009 by Oleg Andreev
#
# ABOUT
#
# Ampoule is a simple distributed bugtracker based on git.
# For each project you should setup a separate git repository and run ./ampoule to get access to the UI
# You may open and close tasks, assign them to someone and add comments.
# Data is automatically synchronized with the remote repository.
#
#
# MIT LICENSE
#
# Copyright (c) 2009 Oleg Andreev <oleganza@gmail.com>
# 
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following
# conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

$KCODE = 'UTF8'
require 'webrick'
require 'CGI'
require 'jcode'
require 'thread'
require 'yaml'

module Kernel
  def const(name, value = nil)
    if !const_defined?(name)
      const_set(name, value || name.to_s.downcase)
    end
  end
end

module Ampoule
  
  const(:VERSION, "0.1")
  
  module GitHelper
    def git_user_name
      @git_user_name ||= `git config user.name`.strip
    end
    
    def git_user_email
      @git_user_email ||= `git config user.email`.strip
    end
    
    def git_user_name=(n)
      n = n.gsub(/["`'\\\n\r\t\v]+/, '')
      `git config user.name "#{n}"`
    end
  end
  
  module FileHelper
    include GitHelper
        
    def file_contents_for_path(path)
      $file_buffer.read(path).to_s.or { nil }
    end
    
    def file_contents_for_name(name)
      file_contents_for_path("_ampoule/#{name}")
    end
    
    def set_file_contents_for_name(content, name)
      path = "_ampoule/#{name}"
      Dir.mkdir("_ampoule") if !File.exists?("_ampoule")
      
      $file_buffer.write(path, content)
    end
    
    def project_title
      (file_contents_for_name("title.txt") || "Click here to change project name").strip
    end

    def set_project_title(new_title)
      set_file_contents_for_name(new_title, "title.txt")
    end

    def tasks
      $file_buffer.glob("_ampoule/*.yaml").map do |path|
        if path =~ %r{/([^/]+)\.yaml$}
          Task.task_with_id_and_yaml($1, file_contents_for_path(path))
        else
          raise "Task id is corrupted? Path: #{path}"
        end
      end
    end

    def task_by_id(id)
      file_contents_for_name(%{#{id}.yaml}).and do |data|
        Task.task_with_id_and_yaml(id, data)
      end
    end
        
    def save_task(task)
      task.mark_as_modified
      set_file_contents_for_name(task.to_yaml, %{#{task.id}.yaml})
    end
    
    def current_user_name=(n)
      self.git_user_name = n
    end
    
    def current_user_name
      git_user_name
    end
    
  end
  
  module PresentationBuilders
    if !defined? BlankSlate
      class BlankSlate
        class <<self; alias __undef_method undef_method; end
        alias __instance_eval instance_eval
        ancestors.inject([]){|m,a| m + a.methods }.uniq.
          each { |m| (__undef_method(m) rescue nil) unless m =~ /^__/ }
      end
    end
    
    class XMLBuilder < BlankSlate
      def initialize(delegate = nil, &blk)
        @delegate = delegate
        @buffer = ""
        __instance_eval(&blk)
      end

      def puts(s)
        print("#{s}\n")
      end

      def print(text)
        @buffer << text
        ""
      end

      def tag(name, attrs = {}, &blk)
        @buffer << %{<#{name}} << (attrs || {}).inject('') do |ra, (k,v)|
          v ? (ra << " " << k.to_s << "=" << '"' << CGI::escapeHTML(v.to_s) << '"') : ra
        end
        if blk
          @buffer << ">" << yield.to_s << "</#{name}>"
        else
          @buffer << " />"
        end
        ""
      end

      def method_missing(name, *args, &blk)
        tag(name, *args, &blk)
      end
      
      def delegate(*methods)
        if methods.empty?
          @delegate
        else
          methods.each do |m|
            class <<self; self; end.send(:define_method, m) { @delegate.send(m) }
          end
        end
      end
      
      def helper(name, &implementation)
        class <<self; self; end.send(:define_method, name, &implementation)
      end
      
      def h(text)
        CGI::escapeHTML(text)
      end
      
      def to_s
        @buffer
      end
    end
      
    class CSSBuilder < BlankSlate

      class ::Numeric
        def em; "#{self}em"; end
        def px; "#{self}px"; end
      end

      def initialize(&blk)
        @css = {}
        @current_selector = ""
        @current_rules = {}
        __instance_eval(&blk)
      end

      def _selector(name, suffix = "", &blk)
        # 0. prepare
        suffix = ":#{suffix}" if suffix.is_a?(Symbol)
        selector = "#{name}#{suffix}"

        # 1. push
        current_selector = @current_selector
        @current_selector = "#{current_selector} #{selector}".strip
        rules = @current_rules
        @current_rules = {}

        yield

        # 2. remember collected stuff
        @css[@current_selector] ||= {}
        @css[@current_selector].merge! @current_rules

        # 3. pop
        @current_rules = rules
        @current_selector = current_selector
      end

      # define an element
      def _(suffix = "", &blk)
        _selector("", suffix, &blk)
      end

      # set any property as-is
      def _set(name, value)
        @current_rules[name.to_s] = value
        nil
      end

      def _property(name, value_or_hash)
        if value_or_hash.is_a?(Hash)
          value_or_hash.inject(nil) do |r, (k, v)|
            _property("#{name}-#{k}", v)
          end
        else
          _set(name.to_s.gsub("_","-"), value_or_hash)
        end
      end

      def method_missing(name, *args, &blk)
        if blk # it is a selector
          _selector(name, *args, &blk)
        else # it is a property
          _property(name, *args)
        end
      end

      def to_s
        @css.inject("") do |css, (selector, props)|
          css << "#{selector} {\n" << (props.inject("") { |_, (k,v)|
            _ << "  #{k}: #{v};\n"
          }) << "}\n"
        end
      end
    end # CSSBuilder
    
    
  end # PresentationBuilders

  #
  # Model
  #
  
  NonreloadableStructs = {} if !defined?(NonreloadableStructs)
  class <<self
    def Model(*attrs)
      key = attrs.map{|a|a.to_s}.join(",")
      model = (NonreloadableStructs[key] ||= Struct.new(*attrs))
      model.send(:include, ModelInstanceMethods)
      model.send(:extend, ModelClassMethods)
      model
    end
  end
  
  module ModelClassMethods
    def default(name, &blk)
      send(:define_method, name) do
        super.or(&blk)
      end
    end
  end
  
  module ModelInstanceMethods
    def initialize(attrs)
      attrs.each do |key, value|
        send("#{key}=", value)
      end
    end
    
    # do not export @ivars
    def to_yaml_properties; []; end
    
    # for to_yaml: access data directly through method sends so that all defaults are used
    def [](key); send(key); end
  end
      
  class Task < Model(:title, :assigned_to, :status, :created_at, :modified_at, :comments)
    attr_accessor :id
    
    const :OPENED
    const :CLOSED
    
    def self.task_with_id_and_yaml(id, data)
      t = YAML.load(data)
      t.id = id
      t
    end
    
    def id
      @id ||= Time.now.strftime("%Y%m%d-%H%M%S-#{rand(2**16).to_s.rjust(5,'0')}")
    end
    
    default(:title)       { "Untitled" }
    default(:assigned_to) { "nobody" }
    default(:created_at)  { Time.now }
    default(:modified_at) { Time.now }
    
    def comments
      super.or { self.comments = [] }
    end
    
    def status
      super == CLOSED ? CLOSED : OPENED
    end
    
    def closed?
      status == CLOSED
    end
    
    def opened?
      !closed?
    end
    
    def last_status_line
      last_comment = comments.last
      return "" if !last_comment
      if !last_comment.body.blank?
        %{#{last_comment.author}: #{last_comment.body.to_short_line}}
      elsif !last_comment.status.blank?
        %{#{last_comment.status} by #{last_comment.author}}
      else
        ""
      end
    end
    
    # mutation methods
        
    def close; self.status = CLOSED; end
    def open;  self.status = OPENED; end
    
    def add_comment(comment)
      comments << comment
    end
    
    def mark_as_modified
      self.modified_at = Time.now
    end
  end
  
  class Comment < Model(:author, :date, :status, :body)
    default(:date) { Time.now }
    def body
      super.to_s
    end
  end
  
  
  #
  # Controllers
  #

  class Controller
    attr_accessor :request, :response
    def initialize(request, response)
      self.request = request
      self.response = response
      response.status = 200
      response['Content-Type'] = "text/html"
    end
    
    def param(param, default = nil)
      r = request.query[param.to_s] || default
      return r.to_s if r.is_a?(String) # fight WEBrick::HTTPUtils::FormData 
      r
    end
    
    def get!
      response.body = get.to_s
    end
    
    def get
      ""
    end
    
    def post!
      post
      if @redirect_to
        response.status = 301
        response['Location'] = @redirect_to
      end
    end
    
    def post
      redirect_to "/"
    end
    
    def redirect_to(uri)
      @redirect_to = uri
    end
  end
  
  module Layout
    include FileHelper
    attr_accessor :page_title
    
    def page_title
      @page_title || project_title 
    end
    
    def layout(attrs_for_body = {}, &blk)
      PresentationBuilders::XMLBuilder.new(self) do
        
        delegate :project_title, :page_title, :current_user_name
        
        helper :tasks_table do |tasks, opts, &blk|
          opts = opts.dup
          cls = ["tasks", opts.delete(:class), opts.delete("class")].compact.join(" ")
          table({:border => 0, :class => cls}.merge(opts)) do

            blk.call if blk

            tasks.each do |task|
              tr do
                td(:class => "task-title textual") do
                  a(:href => "/#{task.id}"){ h(task.title) }
                  small do
                    status = task.last_status_line.gsub(/assigned to .*? (by .*)/i, "reassigned \\1").gsub(/([^\.])\.\Z/,"\\1")
                    puts(h(status) + " ")
                    nobr { task.modified_at.to_relative_string_if_recent.and{|s| "(#{s})" }.to_s} 
                  end
                end
                td(:class => "task-person textual") do
                  h(task.assigned_to)
                end
              end
            end # tasks.each
            
            ""
          end # table
          
        end # helper :tasks_table
        
        helper :formatted_text do |text|
          return "" if text.blank?
          text = text.gsub(/\r\n/, "\n").gsub(/\r/, "\n")
          paragraphs = text.split(/\n\n+/)
          text = paragraphs.map do |paragraph|
            if paragraph[/\n[ \t]+/]
              %{<code><pre>#{h(paragraph)}</pre></code>}
            else
              %{<p>#{hbr(paragraph)}</p>}
            end
          end.join

          # 1. Unwrap link to task 
          text.gsub!(%r{http://localhost:\d+/(\d{8}-\d{6}-\d+)/?}, "task \\1")

          # 2. Wrap task id into link
          text.gsub!(%r{((task|case|bug) (\d{8}-\d{6}-\d+))}, %{<a href="/\\3">\\1</a>})

          # 3. Highlight other links
          text.gsub!(%r{(http://[^\s<>\n\r]+)}) do
            url = $1
            last = url[-1,1]
            if last =~ /[\.:;,?!]/
              url = url[0..-2]
            else
              last = ""
            end
            %{<a href="#{url}">#{url}</a>#{last}}
          end

          text
        end # helper :formatted_text

        helper :hbr do |text|
          h(text.strip).gsub(/\n/, "<br/>")
        end
        
        helper :submit_button do |attrs, &blk|
          input({:type => :submit, 
                 :name => :submit, 
                 :value => :Ok, 
                 :disabled => (attrs.delete(:disabled) ? :disabled : nil)}.merge(attrs), &blk)
        end
        
        
        html do
          head do
            meta "http-equiv" => "Content-Type", :content => "text/html; charset=UTF-8"
            link :rel => "stylesheet", :href=>"/style.css", :type => "text/css"
            title { page_title }
          end
          if domid = attrs_for_body.delete(:focus)
            attrs_for_body[:onload] = %{document.getElementById('#{domid}').focus()} 
          end
          body(attrs_for_body) do
            __instance_eval(&blk) if blk
            br
            br
          end
        end # html
      end # XMLBuilder
    end # layout
        
  end # Layout
  
  class TasksController < Controller
    include Layout
    
    def get
      if current_user_name.blank?
        user_name_prompt
      else
        index
      end
    end
    
    def user_name_prompt
      layout :focus => :username do
        form :action => "/username", :method => "POST" do
          p { "Hello, what is your name?" }
          p { small { "Your name will be stored in .git/config" } }
          p do 
            input(:value => "", :name => :name, :id => :username) 
            submit_button(:value => "save")
          end
        end
      end
    end
    
    def index
      
      opened_tasks = []
      closed_tasks = []
      tasks.each do |t|
        (t.closed? ? closed_tasks : opened_tasks) << t
      end
      opened_tasks = opened_tasks.sort_by {|t| -t.modified_at.to_i }
      closed_tasks = closed_tasks.sort_by {|t| -t.modified_at.to_i }
      
      
      layout :focus => :newitemtitle do
        
        form :action => "/title", :method => "POST" do
          h1(:class => 'index-title') { input(:value => page_title, :name => :title) }
        end
        
        form(:action => "/", :method => :POST, :class => 'new-task') do
          tasks_table(opened_tasks, :class => "opened-tasks") do
            tr :class => "new-task-row" do
              td :class => "task-title" do
                input(:name => "title", :value => "", :id => :newitemtitle)
              end
              td :class => "task-person" do
                value = $last_assigned_person.or { current_user_name }
                nobr do
                  input(:name    => :assigned_to, 
                        :value   => value, 
                        :id      => :newitemperson,  
                        :size => 15)
                  puts("&nbsp;")
                  submit_button(:value => :Assign)
                end
              end # td
            end # tr
          end # tasks_table
        end # new task form
        
        h2 { "Closed tasks" } if !closed_tasks.empty?
        
        tasks_table(closed_tasks, :class => "closed-tasks")
        
      end # layout
    end # index
    
    def post
      title = param(:title)
      assigned_to = param(:assigned_to)
      task = Task.new(:title => title, :assigned_to => assigned_to)
      task.add_comment(Comment.new(:author => current_user_name, :status => "opened"))
      save_task(task)
      $last_assigned_person = assigned_to
      redirect_to "/"
    end
    
  end # TasksController
  
  class TaskController < Controller
    include Layout
    include FileHelper
    
    def task
      @task ||= task_by_id(request.path[1..-1])
    end
    
    def get
      self.page_title = task.title + " (#{project_title})"
      
      layout :focus => :comment do
        
        delegate :task
              
        small(:style => %{position:absolute; top:1em;}) { a(:href => "/") { project_title + " index" } }
        
        form(:action => "/#{task.id}", :method => :POST, :class => 'edit-task') do
          h1 { input(:name => :title, :value => task.title, :class => "task-title") }
          
          div :class => "comments" do
            task.comments.each do |comment|
              label :class => "comment-label" do
                puts(h(comment.author))

                small { comment.status.to_s + " " + comment.date.to_relative_string }
              end
              puts(formatted_text(comment.body))
            end
            ""
          end
          br
          input :class => "current-person", 
                :name => 
                :current_person, 
                :value => current_user_name, 
                :tabindex => -1
          br
          textarea(:name => :comment, :id => :comment, :rows => 10, :cols => 80) { }
          
          div :class => "buttons panel" do
            div :class => "save-button" do
              span :class => "assigned-to" do 
                puts("assigned to ")
                input(:name => "assigned_to", :value => task.assigned_to)
              end
              submit_button(:name => :save, :value => :Save)
            end
            div :class => "status-buttons" do
              submit_button(:name => :close, :value => :Close, :disabled => task.closed?)
              print("&nbsp;")
              submit_button(:name => :reopen, :value => :Reopen, :disabled => task.opened?)
            end
          end
        end # form
        
      end # super do
    end # read
        
    def post
      current_person = param(:current_person)
      if current_person != current_user_name && !current_person.blank?
        self.current_user_name = current_person # remember new value
      end
      
      task.title = param(:title)
      assigned_to = param(:assigned_to)
      
      status = nil
      if task.assigned_to != assigned_to
        status = %{assigned to #{assigned_to}}
      end
      
      task.assigned_to = assigned_to
      
      status_changed = !param(:close).blank? || !param(:reopen).blank?
      
      if status_changed
        if param(:close).blank?
          status ||= "reopened"
          task.open
        else
          status ||= "closed"
          task.close
        end
      end
      
      comment_body = param(:comment)
      if !status.blank? || !comment_body.blank?
        comment = Comment.new(:author => current_user_name,
                              :status => status,
                              :body   => comment_body)
        task.add_comment(comment)
      end
      
      save_task(task)
      
      if status_changed
        redirect_to "/"
      else
        redirect_to  "/#{task.id}"
      end
    end
    
  end # TaskController
  
  
  #
  # CSS
  #
  
  class CSSController < Controller
    def get
      PresentationBuilders::CSSBuilder.new do
        app_font_family = "Helvetica, sans-serif"

        body {
          font   "100% #{app_font_family}"
          color  "#333"
          margin "3em 1em 1em 4em"    
        }

        h1 {
          font_size 1.3.em

          input {
            font  "100% #{app_font_family}"
            width "70%"
          }
        }

        h1 ".index-title" do
          input {
            border        :none
            width         "100%"
            outline_style :none
          }
        end

        h2 { 
          font :size => 1.1.em, :weight => :normal
          margin "1.8em 0 0.5em 0"
          color "#666"
        }

        a { color "#333" }
        a(:hover) { color "#000" }

        _ ".new-task" do
          input do
            font :family => app_font_family, :size => 1.0.em
            margin_left  -3.px
            padding_left  0.px
          end
        end

        _ ".tasks" do
          width       "100%"
          margin_left "-1px"

          td do 
            font     :family => app_font_family, :size => 0.9.em
            padding  "2px 0 5px 0"
          end
          td(".textual") { vertical_align :top }
          td(".task-person") { font_size 0.83.em }
          

          _ ".new-task-row td" do
            padding_top "0.5em"
          end

          a         { color "#333"; text_decoration :none }
          a(:hover) { color "#000"; text_decoration :underline }

          _ ".task-title" do
            width "70%"
            padding_right "7px"

            input { width "100%" }
          end

          small {
            color "#999"
            font_size 0.75.em
            padding_left 0.4.em
          }

        end

        _ ".tasks.closed-tasks" do
          td { color "#666" }
          a  { color "#666" }
          a(:hover) { color "#333" }
        end

        _ ".edit-task" do
          textarea do
            font :size => 0.9.em, :family => app_font_family
            padding 0.4.em
            margin "0.4em 0 0.6em 0"
            word_spacing :normal
            width "70%"
          end

          input ".current-person" do
            padding 0
            margin 0
            border :none
            outline_style :none
            font :size => 0.8.em, :family => app_font_family, :weight => :bold
          end

          div ".panel" do 
            position :relative
            width "70%"
            overflow :hidden
            margin_bottom 0.5.em
          end

          _ ".save-button .assigned-to" do
            font_size 0.9.em
            input do 
              font :size => 1.0.em, :family => app_font_family
              margin_right 0.6.em 
            end
          end

          input '[type="submit"]' do
            font :family => app_font_family, :size => 1.em
            width 5.em
          end

          div(".status-buttons") { float :left }
          div(".save-button")    { float :right }
        end

        _ ".comments" do
          label {
            font :size => 0.8.em, :weight => :bold
            display :block
            margin "2em 0 0.6em 0"
            small {
              font :size => 1.em, :weight => :normal
              color "#999"
              padding_left 0.9.em
            }
          }

          p {
            font_size 0.9.em
            margin "0.3em 0 0.6em 0"
            width "70%"
            line_height "130%"
          }
        end
        
      end # builder
    end # get
    
    def run
      font_family = "Helvetica, sans-serif"
      font = "100% #{font_family}"
      apply(:body, 
        :font => font, 
        :color => "#333",
        :margin => "3em 1em 1em 4em")
        
      apply(:h1, :font_size => 1.3.em) do
        apply(:input,
          :font => font,
          :width => "70%"
        )
      end
      
      with("h1.index-title") do
        apply(:input,
          :border => :none,
          :width => "100%",
          :outline_style => :none
        )
      end
      
      apply(:h2, :font_size => 1.1.em, :font_weight => :normal, :margin => "1.8em 0 0.5em 0", :color => "#666") 
      
      apply("a", :color => "#333")
      apply("a:hover", :color => "#000")

      
      apply(".new-task input", :font_family => font_family, :font_size => 1.0.em, :margin_left => -3.px, :padding_left => 0.px)
      apply(".empty", :color => "#999")
      apply(".tasks", :width=>"100%", :margin_left => "-1px") do
        apply("td", :font_family => font_family, :font_size => 0.9.em, :padding => "2px 0 5px 0")
        apply("td.textual", :vertical_align => :top)
        apply("td.task-person", :font_size => 0.83.em)
        apply(".new-task-row td", :padding_top=>"0.5em")
        
        apply("a", :color => "#333", :text_decoration => "none")
        apply("a:hover", :color => "#000", :text_decoration => "underline")
        
        apply(".task-title", :width=>"70%", :padding_right => "7px") do
          apply("input", :width=>"100%")
        end
        
        apply("small", :color => "#999", :font_size => "0.75em", :padding_left => "0.4em") 
        
      end
      
      apply(".tasks.closed-tasks") do
        apply("td", :color => "#666")
        apply("a", :color => "#666")
        apply("a:hover", :color => "#333")
      end
      
      with(".edit-task") do      
        apply("textarea",
          :padding => 0.4.em,
          :margin => "0.4em 0 0.6em 0",
          :font_size => 0.9.em,
          :font_family => font_family,
          :word_spacing => :normal,
          :width => "70%"
        )
        
        apply("input.current-person", 
          :border => :none,
          :padding => 0,
          :margin => 0,
          :outline_style => :none,
          :font_family => font_family,
          :font_size => 0.8.em,
          :font_weight => "bold")
        
        apply("div.panel", :position => :relative, :width => "70%", :overflow => :hidden, :margin_bottom => "0.5em") 
      
        with(".save-button .assigned-to", :font_size => "0.9em") do
          apply("input", :font_size => "1.0em", :font_family => font_family, :margin_right => "0.6em")
        end
      
        apply(%{input[type="submit"]}, :font => font, :width => "5em")
        
        
        apply("div.status-buttons", :float => "left") 
        apply("div.save-button", :float => "right") 
      end
      
      with(".comments") do
        apply("label", :font_size => 0.8.em, :font_weight => "bold", :display => "block", :margin => "2em 0 0.6em 0") do
          apply("small", :font_size => 1.em, :color => "#999", :padding_left => 0.9.em, :font_weight => "normal")
        end
        apply("p", :font_size => 0.9.em, :margin => "0.3em 0 0.6em 0", :width => "70%", :line_height => "130%")
      end
      
    end
  end
  
  class TitleController < Controller
    include FileHelper
    def post
      set_project_title(param(:title))
      redirect_to "/"
    end
  end
  
  class UsernameController < Controller
    include FileHelper
    def post
      self.current_user_name = param(:name)
      redirect_to "/"
    end
  end
  
  
  #
  # Helpers
  #  
  
  class FileSyncBuffer
    def initialize
      @buffer = {} # path => content
      @queue = Queue.new
      @mutex = Mutex.new
      
      @puller = Thread.new do
        loop do
          sleep(1 + rand(1))
          @queue.push(:pull) if @queue.size < 1
        end
      end
      
      @pusher = Thread.new do
        while msg = @queue.pop
          if msg == :stop
            puts "Ampoule::FileSyncBuffer: stopped."
            break
          end

          `git pull`
          
          if msg == :push
                      
            paths = []
            @mutex.synchronize do
              @buffer.each do |path, data|
                paths << path
                File.open(path, 'w'){|f|f.write(data)}
              end
              @buffer = {}
            end
            
            if !ENV["AMPOULE_NOPUSH"]
              `git add _ampoule; git commit -m "synced #{paths.join(', ')}"; git push`
            end
          end
        end
      end
    end
    
    def stop
      puts "Ampoule::FileSyncBuffer: stopping..."
      @queue.push :stop
      @pusher.join
    end
    
    def read(path)
      @mutex.synchronize do
        @buffer[path] || (File.readable?(path) ? File.open(path){|f|f.read} : nil)
      end
    end
    
    def write(path, data)
      @mutex.synchronize do
        @buffer[path] = data
      end
      @queue.push(:push)
    end
    
    def glob(wildcard)
      @mutex.synchronize do
        (Dir.glob(wildcard) || []) | @buffer.keys.grep(Regexp.new(wildcard.gsub(".","\\.").gsub("*",".*")))
      end
    end
  end
  
  
  
  #
  # Server config
  #
  
  class Server
    def initialize(opts = {})
      @opts = opts
      @port = @opts[:port].to_i
      $file_buffer = FileSyncBuffer.new
      begin
        @server = WEBrick::HTTPServer.new(:Port => @port)
      rescue Errno::EADDRINUSE
        @port += 1
        puts "Ampoule::Server: trying to bind to port #{@port}..."
        retry
      end
      @server.mount "/", WebrickHandle, self
    end
    
    def controller_class_for_request(request)
      case request.path
      when "/":            TasksController
      when "/title":       TitleController
      when "/username":    UsernameController
      when "/style.css":   CSSController
      when "/favicon.ico": Controller
      else                 TaskController
      end
    end
    
    def start
      Thread.new { sleep(1); system(%{open http://localhost:#{@port}/}) }
      trap("INT") { @server.shutdown; $file_buffer.stop }
      @server.start
    end
  end
  
  class WebrickHandle < WEBrick::HTTPServlet::AbstractServlet
    def initialize(_server, router)
      @router = router
      super(_server)
    end
        
    def controller_for_request_and_response(request, response)
      @router.controller_class_for_request(request).new(request, response)
    end
    
    def before
      load(__FILE__) if ENV['AMPOULE_AUTORELOAD']
    end
    
    def do_GET(request, response)
      before
      controller_for_request_and_response(request, response).get!
    end
    
    def do_POST(request, response)
      before
      controller_for_request_and_response(request, response).post!
    end
  end

  module CoreExtensions
    class ::Time
      def to_relative_string
        diff = (Time.now - self).to_i
        return "now" if diff < 2
        return "#{diff} seconds ago" if diff < 50
        return "one minute ago" if diff < 60*2
        return "#{diff/60} minutes ago" if diff < 60*60
        return "an hour ago" if diff/60/60 <= 1
        return "#{diff/60/60} hours ago" if diff < 60*60*18
        return "yesterday" if diff/60/60/24 <= 1
        return "#{diff/60/60/24} days ago" if diff < 60*60*24*7
        return strftime("%B %d") if diff < 60*60*24*30*3
        return strftime("%B %d, %Y")
      end
      def to_relative_string_if_recent
        if Time.now - self < 3600*20
          to_relative_string
        else
          ""
        end
      end
    end
  
    class ::String
      def to_short_line
        max_len = 40
        if gsub("\n"," ") =~ %r{\A(.{10,#{max_len}}\S[\.\?\!\(\[\{]\s)}u
          $1.gsub(/\s*[\(\[\{]\Z/,"")
        elsif self.size > max_len
          split(//u)[0,max_len].join.gsub(/\s*[\(\[\{]\Z/,"") + "..."
        else
          self.gsub(/\s*[\(\[\{]\Z/,"")
        end
      end
    end

    class ::Object
      def blank?; false end
      def or(default = nil)
        blank? ? (block_given? ? yield : default) : self 
      end
      def and
        blank? ? nil : yield(self)
      end
    end
    class ::FalseClass
      def blank?; true end
    end
    class ::NilClass
      def blank?; true end
    end
    class ::Array
      def blank?; compact.empty? end
    end
    class ::String
      def blank?; strip.empty? end
    end
    class ::Hash
      def blank?; values.empty? end
    end
  end # CoreExtensions
end

if $0 == __FILE__
  if !defined?(Ampoule::ServerInstance)
    Ampoule::ServerInstance = Ampoule::Server.new(:port => 8000)
    Ampoule::ServerInstance.start
  end
end
