--- !ruby/struct:Ampoule::Task 
title: find a way to put this on a webserver and still use the git to work offline
priority: today
assigned_to: Oleg Andreev
status: opened
created_at: 2009-11-05 10:13:19.376112 +01:00
modified_at: 2009-11-05 11:17:57.779316 +01:00
comments: 
- !ruby/struct:Ampoule::Comment 
  author: Oleg Andreev
  date: 2009-11-05 10:13:19.376883 +01:00
  status: opened
  body: ""
  attachments: []

- !ruby/struct:Ampoule::Comment 
  author: Oleg Andreev
  date: 2009-11-05 10:40:55.834308 +01:00
  status: 
  body: |
    First, it should fcgi script to be served by Apache, which is the most easy solution. Preferably, the same script used standalone.
    
    Authentication info should be stored inside git repo, so anyone can fix auth issue if it happens.

  attachments: []

- !ruby/struct:Ampoule::Comment 
  author: Oleg Andreev
  date: 2009-11-05 10:52:06.206954 +01:00
  status: 
  body: |
    these could be used to specify committer:
    
     $ man git-commit-tree
    
               GIT_AUTHOR_NAME
               GIT_AUTHOR_EMAIL
               GIT_AUTHOR_DATE
               GIT_COMMITTER_NAME
               GIT_COMMITTER_EMAIL
               GIT_COMMITTER_DATE
               EMAIL

  attachments: []

- !ruby/struct:Ampoule::Comment 
  author: Oleg Andreev
  date: 2009-11-05 10:55:04.935854 +01:00
  status: 
  body: fcgi script should be placed inside a repository checkout, just like regular script is executed. That way, it will know url of the repo.
  attachments: []

- !ruby/struct:Ampoule::Comment 
  author: Oleg Andreev
  date: 2009-11-05 11:17:57.790205 +01:00
  status: 
  body: |
    When running as fcgi, ampoule requires http basic auth with name and password. Name is used later for git-commit.
    
    Encrypted password is taken from the encrypted_line from the users.yaml file:
    
      Oleg Andreev: 
        encrypted_password: e49c75f0d2394ea21a44a38c65486362:1a44a38c68b866q2ec5c75f0e1904ff1
    
      # encrypted_password = sha1(password + ":" + salt)  + ":" + salt
      # salt is a random hex number
    
    Webserver:
    1) takes the name
    2) finds the entry in the users.yaml file
    3) takes the salt, computes sha1(password + ":" + salt) and compares with the encrypted password 
    4) on success, it proceeds; on failure, asks again.

  attachments: []

